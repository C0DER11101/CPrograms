# _1._ \#undef

To _undefine_ a macro that was defined using the #define directive, we use the \#undef directive.

**Syntax:**
```c
#undef macro_name
```

Example:
```c
#define MAX 100

// code

#undef MAX
```

After the \#undef directive, if the macro name is encountered then an error will be generated by the compiler.

Program:
[t18.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t18.c).

**Error:**

<img src="https://user-images.githubusercontent.com/96164229/213915326-e7711497-62ef-4e22-9a5e-26e5542572af.png" width="60%" height="60%">

# _2._ Stringizing operator(\#)

Program:
[t19.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t19.c).


**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213917020-e0edcc02-0777-4b6f-95f4-aef70c7ef21c.png" width="60%" height="60%">

Nothing can best explain this operator than this program.

This stringizing operator copies the name of the actual variable sent as an argument to the macro and places it in the string where this operator was used just like in `t19.c`.

The definition of the macro was:
```c
#define SQUARE(x) printf(#x" x "#x" = %d\n", x*x)
```

`SQUARE()` was called in the `main()` function as: `SQUARE(num)`

Now, in the definition of `SQUARE()`, wherever the portion of the string where `#x` was used, that portion got replaced by the original variable name which was `num` from the `main()` function. The stringizing operator copied the original name of the variable and converted it into a string and hence we got the output: `num x num = 25`.
Since the stringizing converts the variable name to string, we don't need put `#x` within double quotes.

**A property of C:**
Program{[t20.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t20.c)}.

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213917345-a79058d9-cc32-40a0-88f0-cd5fd6bdeba0.png" width="60%" height="60%">

This is the string concatenation property of C.

# _3._ Token pasting operator(\##)
_This operator is used in a macro definition to concatenate two tokens into a single token._

In simple words: `a##b` generates a token `ab`. `y##1` produces `y1`.

Program:
[t21.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t21.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213918246-8a6b7d1a-dc93-4ca0-8e1c-4bca0b9622d8.png" width="60%" height="60%">

Here the token pasting operator `##` pastes `k` and `2` together to produce the variable `k2`(declared in `main()`).

# _4._ Including files

```c
#include<stdio.h>
#include "DisplayBits.c"
```
There difference between when we use `<>` with `include` VS when we use `""` with `include`. Let's look at that difference.

The preprocessor replaces the `#include` directive by the contents of the specified file.

**If the filename is in double quotes**, first it is searched in the current directory(where the source file is present), if not found there then it searched in the standard `include` directory.

**If the filename is within angle brackets**, then the file is searched in the standard `include` directory only.

# _5._ \#if and \#endif
An expression which is followed by \#if is evaluated first,  if the result is non-zero then the statements between \#if and \#endif are compiled, otherwise they are skipped.

\#endif **must** be included at the end of every \#if \#else conditional compilation.

Program:
[t22.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t22.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213932235-29b08acb-b1c8-46dd-a267-c9ad0cffe35a.png" width="60%" height="60%">

**Note:** _The expression of_ `#if` _should  be a **constant expression**, it should not contain enum constants, sizeof operator, cast operator or any keyword or variables. It can contain **arithmetic**, **logical**, **relational** operators. If any undefined identifier appears in the expression, it is treated as having the value zero._

Program:
[t22_2.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t22_2.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213971000-1109a520-51f8-4936-97ef-4d5e23202456.png" width="60%" height="60%">

_Here I used a variable in the expression of_ `#if` _and so only the statement after_ `#endif` _got executed._

# _6._ \#else and \#elif

\#else is used the \#if directive. It is analogous to `if....else` control structure.


**Syntax:**
```c
#if constant-expression
	statements
#else
	statements
#endif
```

Program:
[t23.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t23.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213974217-0a1b3a93-443f-42a2-8fc4-1072534770f5.png" width="60%" height="60%">

\#elif with \#if is analogous to `else...if` ladder.

Program:
[t24.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t24.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213974795-c9692db9-710e-4de4-acf0-0bd58423aafb.png" width="60%" height="60%">

\#elif also evaluates if the expression is a **constant expression**.

# _7._ defined operator
**Syntax:**
```c
defined(macro_name);
```

_This operator is used only with_ **\#if** _and_ **\#elif** _it evaluates to 1(true) if the_ `macro_name` _has been defined using_ `#define`, _otherwise it evaluates to zero._

Program:
[t25.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t25.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/213977120-d0268ded-424a-49f1-90a9-74a932b2c29d.png" width="60%" height="60%">

The `!` operator can be used with `defined()` operator.

# _8._ \#ifdef and \#ifndef

These directives are just the alternate forms of `#if defined(macroName)` and `if !defined(macro_name)`.

`#if defined(macro_name)` $\rightarrow$ equivalent to $\rightarrow$ `#ifdef macro_name`

`#if !defined(macro_name)` $\rightarrow$ equivalent to $\rightarrow$ `#ifndef macro_name`.

Here as well we'll need `#endif` at the end.

_These short forms, however, can't be used everywhere everytime, for example, we can't use these short forms where the existence of more than one macro is to be checked._
**Example:**
```c
#if defined(ABC) && defined(PQR) && !defined(XYZ)
```

_Also, we can't use these short forms with_ `#elif`.

# _9._ Predefined macro names

These are some predefined macro names in C:

## 9.1. __DATE__
_String constant that represents the date of compilation in the format_ `mm dd yyyy`.

## 9.2. __TIME__
_String constant that represents the time of compilation in the format_ `hh:mm:ss`.

## 9.3. __FILE__
_String constant that represents the name of the file being compiled._

## 9.4. __LINE__
_Decimal constant that represents the line number being compiled._

## 9.5. __STDC__
_Decimal constant which is 1 if compiled with ANSI standard._

[This program](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t26.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/214010814-72c20880-37bb-42f4-8e72-29fc65f19988.png" width="60%" height="60%">

# _10._ \#line
**Syntax:**
```c
#line dec_const string_const
```
_Here_ `dec_const` _is any decimal constant and_ `string_const` _is any string constant._

_This directive assigns_ `dec_const` _and_ `string_const` _to the macros_ `__LINE__` _and_ `__FILE__` _respectively._

Program:
[t27.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t27.c).

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/214089791-020503cb-9110-4db2-9448-ec00fc3157a5.png" width="60%" height="60%">

Now, one thing that is noticeable from the output is that I assigned 25 to `__LINE__` but in the output, we see `26` and `27`. How?

When we assign a value to `__LINE__` using `#line`, then the `printf()` right after the `#line` directive will print the value assigned to it.

But the snippet below will print a value added with the number of gaps between the `#line` directive and the `ptinrf()` that is printing the value `__LINE__`.

```c
#line 25 "hello.c"

printf("%d      %s\n", __LINE__, __FILE__);
```
Here the output will be `26` because there is one gap between `#line` and `printf()` statement that is displaying `__LINE__`.

```c
#line 25 "hello.c"


printf("%d      %s\n", __LINE__, __FILE__);
```
Here the output will be `27` because there are 2 gaps between `#line` and `printf()` statement that is displaying `__LINE__`.

```c
#line 25 "hello.c"
printf("hello\n");
printf("This is the #line directive!!\n");
printf("%d      %s\n", __LINE__, __FILE__);
```
Here too the output will be `27` because there are 2 gaps between `#line` and the `printf()` statement that is displyaing `__LINE__`. Although here the two gaps are the two `printf()` statements that are between `#line` and the `printf()` statement displaying `__LINE__`.

# _10._ \#error
\#error directive stops compilation and displays a fatal error attched with it.

Program:
[t28.c](https://github.com/C0DER11101/CPrograms/blob/CProgramming/CPreprocessors/tests/t28.c)

**Output:**

<img src="https://user-images.githubusercontent.com/96164229/214199840-0afb3729-7832-4735-8e07-1a2a2d14890a.png" width="60%" height="60%">




---
